// Code generated by execgen; DO NOT EDIT.

package exec

type selEQInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8
}

func (p *selEQInt8Int8ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selEQInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selEQInt8Int8Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int8Op) Init() {
	p.input.Init()
}

type selNEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8
}

func (p *selNEInt8Int8ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selNEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selNEInt8Int8Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int8Op) Init() {
	p.input.Init()
}

type selLTInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8
}

func (p *selLTInt8Int8ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selLTInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLTInt8Int8Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int8Op) Init() {
	p.input.Init()
}

type selLEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8
}

func (p *selLEInt8Int8ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selLEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLEInt8Int8Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int8Op) Init() {
	p.input.Init()
}

type selGTInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8
}

func (p *selGTInt8Int8ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selGTInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGTInt8Int8Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int8Op) Init() {
	p.input.Init()
}

type selGEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8
}

func (p *selGEInt8Int8ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selGEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGEInt8Int8Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int8Op) Init() {
	p.input.Init()
}

type selEQInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16
}

func (p *selEQInt16Int16ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selEQInt16Int16Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int16Op) Init() {
	p.input.Init()
}

type selNEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16
}

func (p *selNEInt16Int16ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selNEInt16Int16Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int16Op) Init() {
	p.input.Init()
}

type selLTInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16
}

func (p *selLTInt16Int16ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLTInt16Int16Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int16Op) Init() {
	p.input.Init()
}

type selLEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16
}

func (p *selLEInt16Int16ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLEInt16Int16Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int16Op) Init() {
	p.input.Init()
}

type selGTInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16
}

func (p *selGTInt16Int16ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGTInt16Int16Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int16Op) Init() {
	p.input.Init()
}

type selGEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16
}

func (p *selGEInt16Int16ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGEInt16Int16Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int16Op) Init() {
	p.input.Init()
}

type selEQInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32
}

func (p *selEQInt32Int32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selEQInt32Int32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int32Op) Init() {
	p.input.Init()
}

type selNEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32
}

func (p *selNEInt32Int32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selNEInt32Int32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int32Op) Init() {
	p.input.Init()
}

type selLTInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32
}

func (p *selLTInt32Int32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLTInt32Int32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int32Op) Init() {
	p.input.Init()
}

type selLEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32
}

func (p *selLEInt32Int32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLEInt32Int32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int32Op) Init() {
	p.input.Init()
}

type selGTInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32
}

func (p *selGTInt32Int32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGTInt32Int32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int32Op) Init() {
	p.input.Init()
}

type selGEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32
}

func (p *selGEInt32Int32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGEInt32Int32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int32Op) Init() {
	p.input.Init()
}

type selEQInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64
}

func (p *selEQInt64Int64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selEQInt64Int64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int64Op) Init() {
	p.input.Init()
}

type selNEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64
}

func (p *selNEInt64Int64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selNEInt64Int64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int64Op) Init() {
	p.input.Init()
}

type selLTInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64
}

func (p *selLTInt64Int64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLTInt64Int64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int64Op) Init() {
	p.input.Init()
}

type selLEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64
}

func (p *selLEInt64Int64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLEInt64Int64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int64Op) Init() {
	p.input.Init()
}

type selGTInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64
}

func (p *selGTInt64Int64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGTInt64Int64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int64Op) Init() {
	p.input.Init()
}

type selGEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64
}

func (p *selGEInt64Int64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGEInt64Int64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int64Op) Init() {
	p.input.Init()
}

type selEQFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32
}

func (p *selEQFloat32Float32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selEQFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selEQFloat32Float32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Float32Op) Init() {
	p.input.Init()
}

type selNEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32
}

func (p *selNEFloat32Float32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selNEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selNEFloat32Float32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Float32Op) Init() {
	p.input.Init()
}

type selLTFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32
}

func (p *selLTFloat32Float32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selLTFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLTFloat32Float32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Float32Op) Init() {
	p.input.Init()
}

type selLEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32
}

func (p *selLEFloat32Float32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selLEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLEFloat32Float32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Float32Op) Init() {
	p.input.Init()
}

type selGTFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32
}

func (p *selGTFloat32Float32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selGTFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGTFloat32Float32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Float32Op) Init() {
	p.input.Init()
}

type selGEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32
}

func (p *selGEFloat32Float32ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selGEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGEFloat32Float32Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Float32Op) Init() {
	p.input.Init()
}

type selEQFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64
}

func (p *selEQFloat64Float64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] == p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selEQFloat64Float64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] == col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Float64Op) Init() {
	p.input.Init()
}

type selNEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64
}

func (p *selNEFloat64Float64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] != p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selNEFloat64Float64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] != col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Float64Op) Init() {
	p.input.Init()
}

type selLTFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64
}

func (p *selLTFloat64Float64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] < p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLTFloat64Float64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] < col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Float64Op) Init() {
	p.input.Init()
}

type selLEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64
}

func (p *selLEFloat64Float64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] <= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selLEFloat64Float64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] <= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Float64Op) Init() {
	p.input.Init()
}

type selGTFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64
}

func (p *selGTFloat64Float64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] > p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGTFloat64Float64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] > col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Float64Op) Init() {
	p.input.Init()
}

type selGEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64
}

func (p *selGEFloat64Float64ConstOp) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
		var idx uint16
		n := batch.Length()
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col[i] >= p.constArg {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int
}

func (p *selGEFloat64Float64Op) Next() ColBatch {
	for {
		batch := p.input.Next()
		if batch.Length() == 0 {
			return batch
		}

		col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
		col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
		n := batch.Length()

		var idx uint16
		if sel := batch.Selection(); sel != nil {
			sel := sel[:n]
			for _, i := range sel {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		} else {
			batch.SetSelection(true)
			sel := batch.Selection()
			for i := uint16(0); i < n; i++ {
				if col1[i] >= col2[i] {
					sel[idx] = i
					idx++
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Float64Op) Init() {
	p.input.Init()
}
