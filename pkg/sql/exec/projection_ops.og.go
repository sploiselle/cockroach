// Code generated by execgen; DO NOT EDIT.

package exec

type projPlusInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projPlusInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v + p.constArg
		}
	}
	return batch
}

func (p projPlusInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projPlusInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v + col2[i]
		}
	}
	return batch
}

func (p projPlusInt8Int8Op) Init() {
	p.input.Init()
}

type projMinusInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projMinusInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v - p.constArg
		}
	}
	return batch
}

func (p projMinusInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projMinusInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v - col2[i]
		}
	}
	return batch
}

func (p projMinusInt8Int8Op) Init() {
	p.input.Init()
}

type projMultInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projMultInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v * p.constArg
		}
	}
	return batch
}

func (p projMultInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projMultInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v * col2[i]
		}
	}
	return batch
}

func (p projMultInt8Int8Op) Init() {
	p.input.Init()
}

type projDivInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projDivInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v / p.constArg
		}
	}
	return batch
}

func (p projDivInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projDivInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v / col2[i]
		}
	}
	return batch
}

func (p projDivInt8Int8Op) Init() {
	p.input.Init()
}

type projPlusInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projPlusInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v + p.constArg
		}
	}
	return batch
}

func (p projPlusInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projPlusInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v + col2[i]
		}
	}
	return batch
}

func (p projPlusInt16Int16Op) Init() {
	p.input.Init()
}

type projMinusInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projMinusInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v - p.constArg
		}
	}
	return batch
}

func (p projMinusInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projMinusInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v - col2[i]
		}
	}
	return batch
}

func (p projMinusInt16Int16Op) Init() {
	p.input.Init()
}

type projMultInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projMultInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v * p.constArg
		}
	}
	return batch
}

func (p projMultInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projMultInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v * col2[i]
		}
	}
	return batch
}

func (p projMultInt16Int16Op) Init() {
	p.input.Init()
}

type projDivInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projDivInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v / p.constArg
		}
	}
	return batch
}

func (p projDivInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projDivInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v / col2[i]
		}
	}
	return batch
}

func (p projDivInt16Int16Op) Init() {
	p.input.Init()
}

type projPlusInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projPlusInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v + p.constArg
		}
	}
	return batch
}

func (p projPlusInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projPlusInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v + col2[i]
		}
	}
	return batch
}

func (p projPlusInt32Int32Op) Init() {
	p.input.Init()
}

type projMinusInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projMinusInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v - p.constArg
		}
	}
	return batch
}

func (p projMinusInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projMinusInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v - col2[i]
		}
	}
	return batch
}

func (p projMinusInt32Int32Op) Init() {
	p.input.Init()
}

type projMultInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projMultInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v * p.constArg
		}
	}
	return batch
}

func (p projMultInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projMultInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v * col2[i]
		}
	}
	return batch
}

func (p projMultInt32Int32Op) Init() {
	p.input.Init()
}

type projDivInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projDivInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v / p.constArg
		}
	}
	return batch
}

func (p projDivInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projDivInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v / col2[i]
		}
	}
	return batch
}

func (p projDivInt32Int32Op) Init() {
	p.input.Init()
}

type projPlusInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projPlusInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v + p.constArg
		}
	}
	return batch
}

func (p projPlusInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projPlusInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v + col2[i]
		}
	}
	return batch
}

func (p projPlusInt64Int64Op) Init() {
	p.input.Init()
}

type projMinusInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projMinusInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v - p.constArg
		}
	}
	return batch
}

func (p projMinusInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projMinusInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v - col2[i]
		}
	}
	return batch
}

func (p projMinusInt64Int64Op) Init() {
	p.input.Init()
}

type projMultInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projMultInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v * p.constArg
		}
	}
	return batch
}

func (p projMultInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projMultInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v * col2[i]
		}
	}
	return batch
}

func (p projMultInt64Int64Op) Init() {
	p.input.Init()
}

type projDivInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projDivInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v / p.constArg
		}
	}
	return batch
}

func (p projDivInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projDivInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v / col2[i]
		}
	}
	return batch
}

func (p projDivInt64Int64Op) Init() {
	p.input.Init()
}

type projPlusFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projPlusFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v + p.constArg
		}
	}
	return batch
}

func (p projPlusFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projPlusFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v + col2[i]
		}
	}
	return batch
}

func (p projPlusFloat32Float32Op) Init() {
	p.input.Init()
}

type projMinusFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projMinusFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v - p.constArg
		}
	}
	return batch
}

func (p projMinusFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projMinusFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v - col2[i]
		}
	}
	return batch
}

func (p projMinusFloat32Float32Op) Init() {
	p.input.Init()
}

type projMultFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projMultFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v * p.constArg
		}
	}
	return batch
}

func (p projMultFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projMultFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v * col2[i]
		}
	}
	return batch
}

func (p projMultFloat32Float32Op) Init() {
	p.input.Init()
}

type projDivFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projDivFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v / p.constArg
		}
	}
	return batch
}

func (p projDivFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projDivFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v / col2[i]
		}
	}
	return batch
}

func (p projDivFloat32Float32Op) Init() {
	p.input.Init()
}

type projPlusFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projPlusFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v + p.constArg
		}
	}
	return batch
}

func (p projPlusFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projPlusFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v + col2[i]
		}
	}
	return batch
}

func (p projPlusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMinusFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projMinusFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v - p.constArg
		}
	}
	return batch
}

func (p projMinusFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projMinusFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v - col2[i]
		}
	}
	return batch
}

func (p projMinusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMultFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projMultFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v * p.constArg
		}
	}
	return batch
}

func (p projMultFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projMultFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v * col2[i]
		}
	}
	return batch
}

func (p projMultFloat64Float64Op) Init() {
	p.input.Init()
}

type projDivFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projDivFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v / p.constArg
		}
	}
	return batch
}

func (p projDivFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projDivFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v / col2[i]
		}
	}
	return batch
}

func (p projDivFloat64Float64Op) Init() {
	p.input.Init()
}

type projEQInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projEQInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v == p.constArg
		}
	}
	return batch
}

func (p projEQInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projEQInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v == col2[i]
		}
	}
	return batch
}

func (p projEQInt8Int8Op) Init() {
	p.input.Init()
}

type projNEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projNEInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v != p.constArg
		}
	}
	return batch
}

func (p projNEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projNEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v != col2[i]
		}
	}
	return batch
}

func (p projNEInt8Int8Op) Init() {
	p.input.Init()
}

type projLTInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projLTInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v < p.constArg
		}
	}
	return batch
}

func (p projLTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projLTInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v < col2[i]
		}
	}
	return batch
}

func (p projLTInt8Int8Op) Init() {
	p.input.Init()
}

type projLEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projLEInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v <= p.constArg
		}
	}
	return batch
}

func (p projLEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projLEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v <= col2[i]
		}
	}
	return batch
}

func (p projLEInt8Int8Op) Init() {
	p.input.Init()
}

type projGTInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projGTInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v > p.constArg
		}
	}
	return batch
}

func (p projGTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projGTInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v > col2[i]
		}
	}
	return batch
}

func (p projGTInt8Int8Op) Init() {
	p.input.Init()
}

type projGEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projGEInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v >= p.constArg
		}
	}
	return batch
}

func (p projGEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projGEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v >= col2[i]
		}
	}
	return batch
}

func (p projGEInt8Int8Op) Init() {
	p.input.Init()
}

type projEQInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projEQInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v == p.constArg
		}
	}
	return batch
}

func (p projEQInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projEQInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v == col2[i]
		}
	}
	return batch
}

func (p projEQInt16Int16Op) Init() {
	p.input.Init()
}

type projNEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projNEInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v != p.constArg
		}
	}
	return batch
}

func (p projNEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projNEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v != col2[i]
		}
	}
	return batch
}

func (p projNEInt16Int16Op) Init() {
	p.input.Init()
}

type projLTInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projLTInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v < p.constArg
		}
	}
	return batch
}

func (p projLTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projLTInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v < col2[i]
		}
	}
	return batch
}

func (p projLTInt16Int16Op) Init() {
	p.input.Init()
}

type projLEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projLEInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v <= p.constArg
		}
	}
	return batch
}

func (p projLEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projLEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v <= col2[i]
		}
	}
	return batch
}

func (p projLEInt16Int16Op) Init() {
	p.input.Init()
}

type projGTInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projGTInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v > p.constArg
		}
	}
	return batch
}

func (p projGTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projGTInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v > col2[i]
		}
	}
	return batch
}

func (p projGTInt16Int16Op) Init() {
	p.input.Init()
}

type projGEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projGEInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v >= p.constArg
		}
	}
	return batch
}

func (p projGEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projGEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v >= col2[i]
		}
	}
	return batch
}

func (p projGEInt16Int16Op) Init() {
	p.input.Init()
}

type projEQInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projEQInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v == p.constArg
		}
	}
	return batch
}

func (p projEQInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projEQInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v == col2[i]
		}
	}
	return batch
}

func (p projEQInt32Int32Op) Init() {
	p.input.Init()
}

type projNEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projNEInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v != p.constArg
		}
	}
	return batch
}

func (p projNEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projNEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v != col2[i]
		}
	}
	return batch
}

func (p projNEInt32Int32Op) Init() {
	p.input.Init()
}

type projLTInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projLTInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v < p.constArg
		}
	}
	return batch
}

func (p projLTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projLTInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v < col2[i]
		}
	}
	return batch
}

func (p projLTInt32Int32Op) Init() {
	p.input.Init()
}

type projLEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projLEInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v <= p.constArg
		}
	}
	return batch
}

func (p projLEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projLEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v <= col2[i]
		}
	}
	return batch
}

func (p projLEInt32Int32Op) Init() {
	p.input.Init()
}

type projGTInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projGTInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v > p.constArg
		}
	}
	return batch
}

func (p projGTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projGTInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v > col2[i]
		}
	}
	return batch
}

func (p projGTInt32Int32Op) Init() {
	p.input.Init()
}

type projGEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projGEInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v >= p.constArg
		}
	}
	return batch
}

func (p projGEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projGEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v >= col2[i]
		}
	}
	return batch
}

func (p projGEInt32Int32Op) Init() {
	p.input.Init()
}

type projEQInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projEQInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v == p.constArg
		}
	}
	return batch
}

func (p projEQInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projEQInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v == col2[i]
		}
	}
	return batch
}

func (p projEQInt64Int64Op) Init() {
	p.input.Init()
}

type projNEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projNEInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v != p.constArg
		}
	}
	return batch
}

func (p projNEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projNEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v != col2[i]
		}
	}
	return batch
}

func (p projNEInt64Int64Op) Init() {
	p.input.Init()
}

type projLTInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projLTInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v < p.constArg
		}
	}
	return batch
}

func (p projLTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projLTInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v < col2[i]
		}
	}
	return batch
}

func (p projLTInt64Int64Op) Init() {
	p.input.Init()
}

type projLEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projLEInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v <= p.constArg
		}
	}
	return batch
}

func (p projLEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projLEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v <= col2[i]
		}
	}
	return batch
}

func (p projLEInt64Int64Op) Init() {
	p.input.Init()
}

type projGTInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projGTInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v > p.constArg
		}
	}
	return batch
}

func (p projGTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projGTInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v > col2[i]
		}
	}
	return batch
}

func (p projGTInt64Int64Op) Init() {
	p.input.Init()
}

type projGEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projGEInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v >= p.constArg
		}
	}
	return batch
}

func (p projGEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projGEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v >= col2[i]
		}
	}
	return batch
}

func (p projGEInt64Int64Op) Init() {
	p.input.Init()
}

type projEQFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projEQFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v == p.constArg
		}
	}
	return batch
}

func (p projEQFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projEQFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v == col2[i]
		}
	}
	return batch
}

func (p projEQFloat32Float32Op) Init() {
	p.input.Init()
}

type projNEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projNEFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v != p.constArg
		}
	}
	return batch
}

func (p projNEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projNEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v != col2[i]
		}
	}
	return batch
}

func (p projNEFloat32Float32Op) Init() {
	p.input.Init()
}

type projLTFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projLTFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v < p.constArg
		}
	}
	return batch
}

func (p projLTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projLTFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v < col2[i]
		}
	}
	return batch
}

func (p projLTFloat32Float32Op) Init() {
	p.input.Init()
}

type projLEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projLEFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v <= p.constArg
		}
	}
	return batch
}

func (p projLEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projLEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v <= col2[i]
		}
	}
	return batch
}

func (p projLEFloat32Float32Op) Init() {
	p.input.Init()
}

type projGTFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projGTFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v > p.constArg
		}
	}
	return batch
}

func (p projGTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projGTFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v > col2[i]
		}
	}
	return batch
}

func (p projGTFloat32Float32Op) Init() {
	p.input.Init()
}

type projGEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projGEFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v >= p.constArg
		}
	}
	return batch
}

func (p projGEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projGEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v >= col2[i]
		}
	}
	return batch
}

func (p projGEFloat32Float32Op) Init() {
	p.input.Init()
}

type projEQFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projEQFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v == p.constArg
		}
	}
	return batch
}

func (p projEQFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projEQFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v == col2[i]
		}
	}
	return batch
}

func (p projEQFloat64Float64Op) Init() {
	p.input.Init()
}

type projNEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projNEFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v != p.constArg
		}
	}
	return batch
}

func (p projNEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projNEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v != col2[i]
		}
	}
	return batch
}

func (p projNEFloat64Float64Op) Init() {
	p.input.Init()
}

type projLTFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projLTFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v < p.constArg
		}
	}
	return batch
}

func (p projLTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projLTFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v < col2[i]
		}
	}
	return batch
}

func (p projLTFloat64Float64Op) Init() {
	p.input.Init()
}

type projLEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projLEFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v <= p.constArg
		}
	}
	return batch
}

func (p projLEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projLEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v <= col2[i]
		}
	}
	return batch
}

func (p projLEFloat64Float64Op) Init() {
	p.input.Init()
}

type projGTFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projGTFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v > p.constArg
		}
	}
	return batch
}

func (p projGTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projGTFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v > col2[i]
		}
	}
	return batch
}

func (p projGTFloat64Float64Op) Init() {
	p.input.Init()
}

type projGEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projGEFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i, v := range col {
			projCol[i] = v >= p.constArg
		}
	}
	return batch
}

func (p projGEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projGEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i, v := range col1 {
			projCol[i] = v >= col2[i]
		}
	}
	return batch
}

func (p projGEFloat64Float64Op) Init() {
	p.input.Init()
}
