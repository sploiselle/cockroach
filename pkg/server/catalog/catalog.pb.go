// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/catalog/catalog.proto

/*
	Package catalog is a generated protocol buffer package.

	It is generated from these files:
		server/catalog/catalog.proto

	It has these top-level messages:
		Organization
		ChartMetric
		IndividualChart
		ChartSection
*/
package catalog

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_ts_tspb "github.com/cockroachdb/cockroach/pkg/ts/tspb"
import io_prometheus_client "github.com/prometheus/client_model/go"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// AxisUnits describes the Unit options available in the Admin UI
type AxisUnits int32

const (
	AxisUnits_UNSET    AxisUnits = 0
	AxisUnits_COUNT    AxisUnits = 1
	AxisUnits_BYTES    AxisUnits = 2
	AxisUnits_DURATION AxisUnits = 3
)

var AxisUnits_name = map[int32]string{
	0: "UNSET",
	1: "COUNT",
	2: "BYTES",
	3: "DURATION",
}
var AxisUnits_value = map[string]int32{
	"UNSET":    0,
	"COUNT":    1,
	"BYTES":    2,
	"DURATION": 3,
}

func (x AxisUnits) Enum() *AxisUnits {
	p := new(AxisUnits)
	*p = x
	return p
}
func (x AxisUnits) String() string {
	return proto.EnumName(AxisUnits_name, int32(x))
}
func (x *AxisUnits) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AxisUnits_value, data, "AxisUnits")
	if err != nil {
		return err
	}
	*x = AxisUnits(value)
	return nil
}
func (AxisUnits) EnumDescriptor() ([]byte, []int) { return fileDescriptorCatalog, []int{0} }

// DescribeAggregator works as a proxy for cockroach.ts.tspb.TimeSeriesQueryAggregator
// which does not support an unset zero value
type DescribeAggregator int32

const (
	DescribeAggregator_UnsetAgg DescribeAggregator = 0
	// AVG returns the average value of datapoints.
	DescribeAggregator_AVG DescribeAggregator = 1
	// SUM returns the sum value of datapoints.
	DescribeAggregator_SUM DescribeAggregator = 2
	// MAX returns the maximum value of datapoints.
	DescribeAggregator_MAX DescribeAggregator = 3
	// MIN returns the minimum value of datapoints.
	DescribeAggregator_MIN DescribeAggregator = 4
)

var DescribeAggregator_name = map[int32]string{
	0: "UnsetAgg",
	1: "AVG",
	2: "SUM",
	3: "MAX",
	4: "MIN",
}
var DescribeAggregator_value = map[string]int32{
	"UnsetAgg": 0,
	"AVG":      1,
	"SUM":      2,
	"MAX":      3,
	"MIN":      4,
}

func (x DescribeAggregator) Enum() *DescribeAggregator {
	p := new(DescribeAggregator)
	*p = x
	return p
}
func (x DescribeAggregator) String() string {
	return proto.EnumName(DescribeAggregator_name, int32(x))
}
func (x *DescribeAggregator) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescribeAggregator_value, data, "DescribeAggregator")
	if err != nil {
		return err
	}
	*x = DescribeAggregator(value)
	return nil
}
func (DescribeAggregator) EnumDescriptor() ([]byte, []int) { return fileDescriptorCatalog, []int{1} }

// DescribeDerivative works as a proxy for cockroach.ts.tspb.TimeSeriesQueryDerivative
// which has an ambiguous zero value; it's unclear if the value isn't set or if it
// is intentionally set to NONE.
type DescribeDerivative int32

const (
	DescribeDerivative_UnsetDer DescribeDerivative = 0
	// NONE is the default value, and does not apply a derivative function.
	DescribeDerivative_NONE DescribeDerivative = 1
	// DERIVATIVE returns the first-order derivative of values in the time series.
	DescribeDerivative_DERIVATIVE DescribeDerivative = 2
	// NON_NEGATIVE_DERIVATIVE returns only non-negative values of the first-order
	// derivative; negative values are returned as zero. This should be used for
	// counters that monotonically increase, but might wrap or reset.
	DescribeDerivative_NON_NEGATIVE_DERIVATIVE DescribeDerivative = 3
)

var DescribeDerivative_name = map[int32]string{
	0: "UnsetDer",
	1: "NONE",
	2: "DERIVATIVE",
	3: "NON_NEGATIVE_DERIVATIVE",
}
var DescribeDerivative_value = map[string]int32{
	"UnsetDer":                0,
	"NONE":                    1,
	"DERIVATIVE":              2,
	"NON_NEGATIVE_DERIVATIVE": 3,
}

func (x DescribeDerivative) Enum() *DescribeDerivative {
	p := new(DescribeDerivative)
	*p = x
	return p
}
func (x DescribeDerivative) String() string {
	return proto.EnumName(DescribeDerivative_name, int32(x))
}
func (x *DescribeDerivative) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescribeDerivative_value, data, "DescribeDerivative")
	if err != nil {
		return err
	}
	*x = DescribeDerivative(value)
	return nil
}
func (DescribeDerivative) EnumDescriptor() ([]byte, []int) { return fileDescriptorCatalog, []int{2} }

type Organization struct {
	Taxonomy []string `protobuf:"bytes,1,rep,name=Taxonomy" json:"Taxonomy,omitempty"`
}

func (m *Organization) Reset()                    { *m = Organization{} }
func (m *Organization) String() string            { return proto.CompactTextString(m) }
func (*Organization) ProtoMessage()               {}
func (*Organization) Descriptor() ([]byte, []int) { return fileDescriptorCatalog, []int{0} }

// ChartMetric converts cockroach.util.metric.Metadata
// into a struct that's useful for generating Admin UI charts
type ChartMetric struct {
	Name           string                          `protobuf:"bytes,1,req,name=name" json:"name"`
	Help           string                          `protobuf:"bytes,2,req,name=help" json:"help"`
	AxisLabel      string                          `protobuf:"bytes,3,req,name=axisLabel" json:"axisLabel"`
	PreferredUnits AxisUnits                       `protobuf:"varint,4,req,name=preferredUnits,enum=cockroach.server.catalog.AxisUnits" json:"preferredUnits"`
	MetricType     io_prometheus_client.MetricType `protobuf:"varint,5,opt,name=metricType,enum=io.prometheus.client.MetricType" json:"metricType"`
}

func (m *ChartMetric) Reset()                    { *m = ChartMetric{} }
func (m *ChartMetric) String() string            { return proto.CompactTextString(m) }
func (*ChartMetric) ProtoMessage()               {}
func (*ChartMetric) Descriptor() ([]byte, []int) { return fileDescriptorCatalog, []int{1} }

// IndividualChart describes both the properties necessary to display
// AdminUI charts, as well as a key to find them (collectionname)
type IndividualChart struct {
	Title          string                                       `protobuf:"bytes,1,req,name=title" json:"title"`
	Longname       string                                       `protobuf:"bytes,2,req,name=longname" json:"longname"`
	Collectionname string                                       `protobuf:"bytes,3,req,name=collectionname" json:"collectionname"`
	Downsampler    *cockroach_ts_tspb.TimeSeriesQueryAggregator `protobuf:"varint,4,req,name=downsampler,enum=cockroach.ts.tspb.TimeSeriesQueryAggregator" json:"downsampler,omitempty"`
	Aggregator     *cockroach_ts_tspb.TimeSeriesQueryAggregator `protobuf:"varint,5,req,name=aggregator,enum=cockroach.ts.tspb.TimeSeriesQueryAggregator" json:"aggregator,omitempty"`
	Derivative     *cockroach_ts_tspb.TimeSeriesQueryDerivative `protobuf:"varint,6,req,name=derivative,enum=cockroach.ts.tspb.TimeSeriesQueryDerivative" json:"derivative,omitempty"`
	Units          AxisUnits                                    `protobuf:"varint,7,req,name=units,enum=cockroach.server.catalog.AxisUnits" json:"units"`
	AxisLabel      string                                       `protobuf:"bytes,8,req,name=axisLabel" json:"axisLabel"`
	Percentiles    bool                                         `protobuf:"varint,9,req,name=percentiles" json:"percentiles"`
	Data           []ChartMetric                                `protobuf:"bytes,10,rep,name=data" json:"data"`
}

func (m *IndividualChart) Reset()                    { *m = IndividualChart{} }
func (m *IndividualChart) String() string            { return proto.CompactTextString(m) }
func (*IndividualChart) ProtoMessage()               {}
func (*IndividualChart) Descriptor() ([]byte, []int) { return fileDescriptorCatalog, []int{2} }

// ChartSection describes levels of organization for catalog charts
type ChartSection struct {
	Name           string             `protobuf:"bytes,1,req,name=name" json:"name"`
	Longname       string             `protobuf:"bytes,2,req,name=longname" json:"longname"`
	Collectionname string             `protobuf:"bytes,3,req,name=collectionname" json:"collectionname"`
	Description    string             `protobuf:"bytes,4,req,name=description" json:"description"`
	Level          int32              `protobuf:"varint,5,req,name=level" json:"level"`
	Subsections    []*ChartSection    `protobuf:"bytes,6,rep,name=subsections" json:"subsections,omitempty"`
	Charts         []*IndividualChart `protobuf:"bytes,7,rep,name=charts" json:"charts,omitempty"`
}

func (m *ChartSection) Reset()                    { *m = ChartSection{} }
func (m *ChartSection) String() string            { return proto.CompactTextString(m) }
func (*ChartSection) ProtoMessage()               {}
func (*ChartSection) Descriptor() ([]byte, []int) { return fileDescriptorCatalog, []int{3} }

func init() {
	proto.RegisterType((*Organization)(nil), "cockroach.server.catalog.Organization")
	proto.RegisterType((*ChartMetric)(nil), "cockroach.server.catalog.ChartMetric")
	proto.RegisterType((*IndividualChart)(nil), "cockroach.server.catalog.IndividualChart")
	proto.RegisterType((*ChartSection)(nil), "cockroach.server.catalog.ChartSection")
	proto.RegisterEnum("cockroach.server.catalog.AxisUnits", AxisUnits_name, AxisUnits_value)
	proto.RegisterEnum("cockroach.server.catalog.DescribeAggregator", DescribeAggregator_name, DescribeAggregator_value)
	proto.RegisterEnum("cockroach.server.catalog.DescribeDerivative", DescribeDerivative_name, DescribeDerivative_value)
}
func (m *Organization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Organization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Taxonomy) > 0 {
		for _, s := range m.Taxonomy {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ChartMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Help)))
	i += copy(dAtA[i:], m.Help)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.AxisLabel)))
	i += copy(dAtA[i:], m.AxisLabel)
	dAtA[i] = 0x20
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(m.PreferredUnits))
	dAtA[i] = 0x28
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(m.MetricType))
	return i, nil
}

func (m *IndividualChart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndividualChart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Title)))
	i += copy(dAtA[i:], m.Title)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Longname)))
	i += copy(dAtA[i:], m.Longname)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Collectionname)))
	i += copy(dAtA[i:], m.Collectionname)
	if m.Downsampler == nil {
		return 0, proto.NewRequiredNotSetError("downsampler")
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCatalog(dAtA, i, uint64(*m.Downsampler))
	}
	if m.Aggregator == nil {
		return 0, proto.NewRequiredNotSetError("aggregator")
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCatalog(dAtA, i, uint64(*m.Aggregator))
	}
	if m.Derivative == nil {
		return 0, proto.NewRequiredNotSetError("derivative")
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCatalog(dAtA, i, uint64(*m.Derivative))
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(m.Units))
	dAtA[i] = 0x42
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.AxisLabel)))
	i += copy(dAtA[i:], m.AxisLabel)
	dAtA[i] = 0x48
	i++
	if m.Percentiles {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x52
			i++
			i = encodeVarintCatalog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ChartSection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartSection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Longname)))
	i += copy(dAtA[i:], m.Longname)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Collectionname)))
	i += copy(dAtA[i:], m.Collectionname)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Description)))
	i += copy(dAtA[i:], m.Description)
	dAtA[i] = 0x28
	i++
	i = encodeVarintCatalog(dAtA, i, uint64(m.Level))
	if len(m.Subsections) > 0 {
		for _, msg := range m.Subsections {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCatalog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Charts) > 0 {
		for _, msg := range m.Charts {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCatalog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintCatalog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Organization) Size() (n int) {
	var l int
	_ = l
	if len(m.Taxonomy) > 0 {
		for _, s := range m.Taxonomy {
			l = len(s)
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	return n
}

func (m *ChartMetric) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCatalog(uint64(l))
	l = len(m.Help)
	n += 1 + l + sovCatalog(uint64(l))
	l = len(m.AxisLabel)
	n += 1 + l + sovCatalog(uint64(l))
	n += 1 + sovCatalog(uint64(m.PreferredUnits))
	n += 1 + sovCatalog(uint64(m.MetricType))
	return n
}

func (m *IndividualChart) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	n += 1 + l + sovCatalog(uint64(l))
	l = len(m.Longname)
	n += 1 + l + sovCatalog(uint64(l))
	l = len(m.Collectionname)
	n += 1 + l + sovCatalog(uint64(l))
	if m.Downsampler != nil {
		n += 1 + sovCatalog(uint64(*m.Downsampler))
	}
	if m.Aggregator != nil {
		n += 1 + sovCatalog(uint64(*m.Aggregator))
	}
	if m.Derivative != nil {
		n += 1 + sovCatalog(uint64(*m.Derivative))
	}
	n += 1 + sovCatalog(uint64(m.Units))
	l = len(m.AxisLabel)
	n += 1 + l + sovCatalog(uint64(l))
	n += 2
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	return n
}

func (m *ChartSection) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCatalog(uint64(l))
	l = len(m.Longname)
	n += 1 + l + sovCatalog(uint64(l))
	l = len(m.Collectionname)
	n += 1 + l + sovCatalog(uint64(l))
	l = len(m.Description)
	n += 1 + l + sovCatalog(uint64(l))
	n += 1 + sovCatalog(uint64(m.Level))
	if len(m.Subsections) > 0 {
		for _, e := range m.Subsections {
			l = e.Size()
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	if len(m.Charts) > 0 {
		for _, e := range m.Charts {
			l = e.Size()
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	return n
}

func sovCatalog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCatalog(x uint64) (n int) {
	return sovCatalog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Organization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Organization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Organization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taxonomy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taxonomy = append(m.Taxonomy, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartMetric) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Help", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Help = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AxisLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AxisLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferredUnits", wireType)
			}
			m.PreferredUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreferredUnits |= (AxisUnits(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricType", wireType)
			}
			m.MetricType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetricType |= (io_prometheus_client.MetricType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("help")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("axisLabel")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return proto.NewRequiredNotSetError("preferredUnits")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndividualChart) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndividualChart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndividualChart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collectionname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collectionname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downsampler", wireType)
			}
			var v cockroach_ts_tspb.TimeSeriesQueryAggregator
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (cockroach_ts_tspb.TimeSeriesQueryAggregator(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Downsampler = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var v cockroach_ts_tspb.TimeSeriesQueryAggregator
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (cockroach_ts_tspb.TimeSeriesQueryAggregator(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Aggregator = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivative", wireType)
			}
			var v cockroach_ts_tspb.TimeSeriesQueryDerivative
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (cockroach_ts_tspb.TimeSeriesQueryDerivative(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Derivative = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			m.Units = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Units |= (AxisUnits(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AxisLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AxisLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Percentiles = bool(v != 0)
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, ChartMetric{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("title")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("longname")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("collectionname")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return proto.NewRequiredNotSetError("downsampler")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return proto.NewRequiredNotSetError("aggregator")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return proto.NewRequiredNotSetError("derivative")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return proto.NewRequiredNotSetError("units")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return proto.NewRequiredNotSetError("axisLabel")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return proto.NewRequiredNotSetError("percentiles")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartSection) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartSection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartSection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collectionname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collectionname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subsections = append(m.Subsections, &ChartSection{})
			if err := m.Subsections[len(m.Subsections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charts = append(m.Charts, &IndividualChart{})
			if err := m.Charts[len(m.Charts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("longname")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("collectionname")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return proto.NewRequiredNotSetError("description")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return proto.NewRequiredNotSetError("level")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCatalog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCatalog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCatalog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCatalog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCatalog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCatalog   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("server/catalog/catalog.proto", fileDescriptorCatalog) }

var fileDescriptorCatalog = []byte{
	// 747 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xdd, 0x6e, 0xe3, 0x44,
	0x18, 0x8d, 0x9d, 0xa4, 0x4d, 0xbe, 0x54, 0xc1, 0x1a, 0x21, 0x61, 0x15, 0x14, 0x42, 0xd0, 0x56,
	0xa1, 0x5a, 0x39, 0x52, 0x2f, 0xb9, 0x59, 0xa5, 0x9b, 0xec, 0x12, 0x69, 0xeb, 0x68, 0x13, 0xa7,
	0x62, 0xb9, 0xa9, 0xa6, 0xf6, 0x87, 0x3b, 0xc2, 0xf6, 0x58, 0x33, 0x93, 0xd0, 0x72, 0xc5, 0x23,
	0xf0, 0x36, 0xbc, 0x42, 0xb9, 0xe3, 0x92, 0x2b, 0x04, 0xe5, 0x45, 0xd0, 0x8c, 0xdd, 0xc4, 0x5b,
	0x51, 0xfe, 0xb4, 0x57, 0xf9, 0x72, 0xce, 0x77, 0x8e, 0x3c, 0x67, 0xce, 0xc0, 0x47, 0x12, 0xc5,
	0x06, 0xc5, 0x28, 0xa4, 0x8a, 0x26, 0x3c, 0xbe, 0xff, 0xf5, 0x72, 0xc1, 0x15, 0x27, 0x6e, 0xc8,
	0xc3, 0x6f, 0x04, 0xa7, 0xe1, 0x95, 0x57, 0xec, 0x79, 0x25, 0x7f, 0xe8, 0x2a, 0x39, 0x52, 0x32,
	0xbf, 0x1c, 0x29, 0x96, 0xa2, 0x44, 0xc1, 0x50, 0x16, 0x9a, 0xc3, 0xf7, 0x63, 0x1e, 0x73, 0x33,
	0x8e, 0xf4, 0x54, 0xa2, 0x4f, 0x72, 0xc1, 0x53, 0x54, 0x57, 0xb8, 0x96, 0xa3, 0x30, 0x61, 0x98,
	0xa9, 0x8b, 0x94, 0x47, 0x98, 0x8c, 0x52, 0x54, 0x82, 0x85, 0xa5, 0x78, 0x70, 0x0c, 0x07, 0x73,
	0x11, 0xd3, 0x8c, 0x7d, 0x47, 0x15, 0xe3, 0x19, 0x39, 0x84, 0x56, 0x40, 0xaf, 0x79, 0xc6, 0xd3,
	0x1b, 0xd7, 0xea, 0xd7, 0x87, 0xed, 0xc5, 0xf6, 0xff, 0xe0, 0x7b, 0x1b, 0x3a, 0xcf, 0xaf, 0xa8,
	0x50, 0x67, 0xc6, 0x82, 0xb8, 0xd0, 0xc8, 0x68, 0x8a, 0xae, 0xd5, 0xb7, 0x87, 0xed, 0xd3, 0xc6,
	0xed, 0xaf, 0x1f, 0xd7, 0x16, 0x06, 0xd1, 0xcc, 0x15, 0x26, 0xb9, 0x6b, 0x57, 0x19, 0x8d, 0x90,
	0x01, 0xb4, 0xe9, 0x35, 0x93, 0xaf, 0xe8, 0x25, 0x26, 0x6e, 0xbd, 0x42, 0xef, 0x60, 0xf2, 0x1a,
	0xba, 0xb9, 0xc0, 0xaf, 0x51, 0x08, 0x8c, 0x56, 0x19, 0x53, 0xd2, 0x6d, 0xf4, 0xed, 0x61, 0xf7,
	0xe4, 0x53, 0xef, 0xb1, 0x74, 0xbc, 0xf1, 0x35, 0x93, 0x66, 0xb5, 0x74, 0x7b, 0x60, 0x40, 0x5e,
	0x00, 0x14, 0xe7, 0x0e, 0x6e, 0x72, 0x74, 0x9b, 0x7d, 0x6b, 0xd8, 0x3d, 0xe9, 0x7b, 0xcc, 0x84,
	0x55, 0xa6, 0xe4, 0x15, 0x29, 0x79, 0x67, 0xdb, 0xbd, 0xd2, 0xab, 0xa2, 0x1c, 0xfc, 0xd8, 0x80,
	0xf7, 0x66, 0x59, 0xc4, 0x36, 0x2c, 0x5a, 0xd3, 0xc4, 0x84, 0x41, 0x0e, 0xa1, 0xa9, 0x98, 0x4a,
	0xde, 0xce, 0xa1, 0x80, 0x48, 0x1f, 0x5a, 0x09, 0xcf, 0x62, 0x13, 0x53, 0x35, 0x8c, 0x2d, 0x4a,
	0x9e, 0x42, 0x37, 0xe4, 0x49, 0x82, 0xa1, 0x8e, 0xdf, 0xec, 0x55, 0x53, 0x79, 0xc0, 0x11, 0x1f,
	0x3a, 0x11, 0xff, 0x36, 0x93, 0x34, 0xcd, 0x13, 0x14, 0x65, 0x2e, 0x4f, 0x2b, 0xb9, 0x28, 0xe9,
	0xe9, 0x96, 0x78, 0x01, 0x4b, 0x71, 0x69, 0x5a, 0xf2, 0x7a, 0x8d, 0xe2, 0x66, 0x1c, 0xc7, 0x02,
	0x63, 0xaa, 0xb8, 0x58, 0x54, 0x0d, 0xc8, 0x2b, 0x00, 0xba, 0xa5, 0xdc, 0xe6, 0xff, 0xb0, 0xab,
	0xe8, 0xb5, 0x5b, 0x84, 0x82, 0x6d, 0xa8, 0x62, 0x1b, 0x74, 0xf7, 0xfe, 0xad, 0xdb, 0x64, 0xab,
	0x59, 0x54, 0xf4, 0xe4, 0x19, 0x34, 0xd7, 0xe6, 0xf6, 0xf7, 0xff, 0xeb, 0xed, 0x17, 0xba, 0xb7,
	0xbb, 0xd6, 0xfa, 0xeb, 0xae, 0x1d, 0x41, 0x27, 0x47, 0x11, 0x62, 0xa6, 0x58, 0x82, 0xd2, 0x6d,
	0xf7, 0xed, 0x61, 0xab, 0xdc, 0xaa, 0x12, 0xe4, 0x19, 0x34, 0x22, 0xaa, 0xa8, 0x0b, 0xfd, 0xfa,
	0xb0, 0x73, 0xf2, 0xe4, 0xf1, 0x6f, 0xa9, 0x3c, 0x90, 0xfb, 0xe2, 0x6b, 0xe1, 0xe0, 0x27, 0x1b,
	0x0e, 0x0c, 0xb7, 0x2c, 0xae, 0xf3, 0x6f, 0x5e, 0xcf, 0xbb, 0x2e, 0xcd, 0x11, 0x74, 0x22, 0x94,
	0xa1, 0x60, 0xb9, 0x86, 0x4c, 0x69, 0xee, 0x57, 0xab, 0x84, 0x2e, 0x72, 0x82, 0x1b, 0x4c, 0x4c,
	0x0f, 0x9a, 0xf7, 0x59, 0x1a, 0x88, 0x7c, 0x01, 0x1d, 0xb9, 0xbe, 0x94, 0x85, 0xab, 0x74, 0xf7,
	0x4c, 0x0c, 0x47, 0xff, 0x10, 0x43, 0x79, 0xd4, 0x45, 0x55, 0x4a, 0xc6, 0xb0, 0x17, 0x6a, 0x52,
	0xdf, 0xab, 0x36, 0xf9, 0xec, 0x71, 0x93, 0x07, 0x2f, 0x6d, 0x51, 0x0a, 0x8f, 0x3f, 0x87, 0xf6,
	0xf6, 0xca, 0x49, 0x1b, 0x9a, 0x2b, 0x7f, 0x39, 0x0d, 0x9c, 0x9a, 0x1e, 0x9f, 0xcf, 0x57, 0x7e,
	0xe0, 0x58, 0x7a, 0x3c, 0x7d, 0x13, 0x4c, 0x97, 0x8e, 0x4d, 0x0e, 0xa0, 0x35, 0x59, 0x2d, 0xc6,
	0xc1, 0x6c, 0xee, 0x3b, 0xf5, 0xe3, 0x17, 0x40, 0x26, 0xe6, 0xcc, 0x97, 0xb8, 0x6b, 0xb1, 0xde,
	0x59, 0x65, 0x12, 0xd5, 0x38, 0x8e, 0x9d, 0x1a, 0xd9, 0x87, 0xfa, 0xf8, 0xfc, 0xa5, 0x63, 0xe9,
	0x61, 0xb9, 0x3a, 0x73, 0x6c, 0x3d, 0x9c, 0x8d, 0xbf, 0x74, 0xea, 0x66, 0x98, 0xf9, 0x4e, 0xe3,
	0xf8, 0xcd, 0xce, 0x67, 0xd7, 0xdf, 0xad, 0xcf, 0x04, 0x85, 0x53, 0x23, 0x2d, 0x68, 0xf8, 0x73,
	0x7f, 0xea, 0x58, 0xa4, 0x0b, 0x30, 0x99, 0x2e, 0x66, 0xe7, 0xe3, 0x60, 0x76, 0x3e, 0x75, 0x6c,
	0xf2, 0x21, 0x7c, 0xe0, 0xcf, 0xfd, 0x0b, 0x7f, 0xfa, 0xd2, 0x20, 0x17, 0x15, 0xb2, 0x7e, 0xfa,
	0xc9, 0xed, 0xef, 0xbd, 0xda, 0xed, 0x5d, 0xcf, 0xfa, 0xf9, 0xae, 0x67, 0xfd, 0x72, 0xd7, 0xb3,
	0x7e, 0xbb, 0xeb, 0x59, 0x3f, 0xfc, 0xd1, 0xab, 0x7d, 0xb5, 0x5f, 0x26, 0xf3, 0x67, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x8f, 0xbe, 0x65, 0xc5, 0x46, 0x06, 0x00, 0x00,
}
